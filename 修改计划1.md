找到目前的问题是没有在查找的时候只查找到了查询标签，而并没有查不在查询标签集合内，关联度比较高的标签，所以说想要达到的效果并没有达到。

所以基于这个，目前想到改进的措施是：

因为filtered-diskann只支持单属性查询，所以我们在查询的时候把单标签的查询改成标签集合的查询。

如果要查询1号标签的fanns，可以把和1号标签关联度最高的若干个属性也加进来。这样可能达到想要的效果。

所以我的设想是再为每个属性维护一个set<pair<相关度,标签id>>来记录和这个标签相关系数最大的那个标签是什么，然后我可以在查找的时候取查询标签最相关的若干个其他标签也加入进查询的集合里去查询。

下面是gemini pro 2.5给我的改进方案：

好的，我理解了你的新思路和遇到的问题。之前的方案（在建图剪枝时引入`beta`）无法达到预期效果，是因为搜索过程本身仍然严格按照**查询时提供的标签**进行过滤，不会自动探索那些虽然没有直接匹配、但与查询标签高度相关的标签。

你的新方案——**在查询阶段动态扩展标签集**——是更直接有效的方法。我们来规划一下如何实现这个方案：

---

### **改进方案规划：基于相关性的查询标签扩展**

**核心思想**：当用户查询单个标签 `L` 时，系统自动查找与 `L` 最相关的 `k` 个其他标签，并将这 `k+1` 个标签作为一个整体（使用OR逻辑）进行过滤搜索。

**实施步骤**：

#### **阶段一：增强相关性信息的存储**

**目的**：不仅存储标签间的相关性分数，还要能快速检索出与每个标签最相关的 Top-K 标签。

1.  **新增数据结构**：
    * 在 `Index` 类（`include/index.h`）中，除了之前讨论的 `_label_correlation_matrix` (存储所有相关性分数)，再添加一个新的成员变量，例如：
        `std::unordered_map<LabelT, std::vector<std::pair<float, LabelT>>> _label_top_correlations;`
    * 这个结构将存储每个 `LabelT` 到一个 **已排序** (按相关度从高到低) 的 `pair` 列表的映射。每个 `pair` 包含 `<相关度分数, 相关的标签ID>`。

2.  **修改相关性计算函数 (`calculate_label_correlations`)**：
    * **文件**: `src/index.cpp`
    * **逻辑**:
        * 在计算完所有标签对的相关性分数并填充 `_label_correlation_matrix` 之后（使用Ochiai系数）。
        * 增加一个新的循环，遍历所有已知的标签 `L`。
        * 对于每个标签 `L`，从 `_label_correlation_matrix` 中提取所有与 `L` 相关的 `(邻居标签, 相关度分数)` 对。
        * 将这些对按照相关度分数**降序**排序。
        * 取排序后的前 `k` 个 `pair` (你需要添加一个新的配置参数 `num_correlated_labels_to_expand` 来指定 `k` 的值)。
        * 将这 Top-K 个 `pair` 存储到 `_label_top_correlations[L]` 中。

3.  **添加配置参数**:
    * 在 `IndexWriteParameters` (`include/index_build_params.h`) 中添加 `num_correlated_labels_to_expand` (uint32_t类型，默认值为0)。
    * 在 `Index` 类 (`include/index.h`) 中添加对应的成员变量 `_num_correlated_labels_to_expand` 并在构造函数 (`src/index.cpp`) 中初始化。

#### **阶段二：修改搜索入口函数**

**目的**：在执行搜索前，根据用户提供的单个查询标签，自动扩展为一个标签集合。

1.  **调整 `search_with_filters` (及相关函数) 内部逻辑**:
    * **文件**: `src/index.cpp`
    * **定位**: 找到 `search_with_filters` 函数（以及可能需要修改的 `_search_with_filters` 或处理过滤的 `search_with_tags` 部分）。
    * **逻辑修改**:
        * 函数仍然接收**单个**原始查询标签 `original_query_label` (可以是 `LabelT` 或 `std::string`)。
        * 在函数开头，创建一个空的 `std::vector<LabelT> expanded_filter_labels`。
        * 将 `original_query_label` (如果是字符串，先转换成 `LabelT`) 添加到 `expanded_filter_labels` 中。
        * **检查扩展条件**: 如果 `_num_correlated_labels_to_expand > 0` （即用户在构建索引时指定了要扩展的数量）：
            * 使用 `original_query_label` (转换后的 `LabelT`) 作为键，在 `_label_top_correlations` 中查找其对应的 Top-K 相关标签列表。
            * 如果找到了列表，遍历该列表，将列表中每个 `pair` 的第二个元素 (即 `LabelT` ID) 添加到 `expanded_filter_labels` 中。
            * （可选）确保 `expanded_filter_labels` 中的标签是唯一的（例如使用 `std::set` 辅助或排序后去重）。
        * **传递扩展后的标签集**: 在调用核心搜索函数 `iterate_to_fixed_point` 时，将 `expanded_filter_labels` 作为 `filter_labels` 参数传递进去。

2.  **调整命令行工具接口 (可选但推荐)**:
    * **文件**: `apps/search_memory_index.cpp`, `apps/search_disk_index.cpp`
    * **目的**: 让用户在搜索时也能控制是否以及如何进行标签扩展。
    * **方案**:
        * 可以添加一个新的命令行参数，例如 `--expand_labels_k` (uint32_t)。如果用户提供了这个参数且值大于0，则覆盖构建时设置的 `_num_correlated_labels_to_expand` 值，执行标签扩展。如果用户不提供此参数或设为0，则只使用原始查询标签。
        * 在 C++ 代码中读取这个新的命令行参数，并在 `search_with_filters` 的标签扩展逻辑中使用它来决定 `k` 的值。
        * **注意**: `--filter_label` 参数仍然只接受一个原始查询标签。扩展是在 C++ 代码内部完成的。

#### **阶段三：保持核心搜索和建图逻辑不变**

* **核心搜索 (`iterate_to_fixed_point`)**: 不需要修改。它已经接受 `std::vector<LabelT>` 并执行 "OR" 逻辑匹配。
* **核心建图 (`occlude_list`)**: 不需要修改。之前的 `beta` 方案可以移除，因为现在的核心思路是在查询时扩展标签集。

#### **阶段四：测试与评估**

1.  **构建索引**: 使用 `--num_correlated_labels_to_expand K` （K > 0）参数构建索引，确保 Top-K 相关标签信息被计算和存储。
2.  **执行搜索**:
    * 使用搜索命令行工具，提供**单个** `--filter_label L`。
    * （如果实现了可选的搜索时扩展参数）可以尝试使用 `--expand_labels_k K'` 来控制查询时的扩展数量。
3.  **结果验证**:
    * 检查返回结果是否包含了原始标签 `L` **或** 与 `L` 高度相关的 Top-K' 标签中的任意一个。
    * **评估**: 评估召回率时，通常仍以原始查询标签 `L` 的 Ground Truth 为基准，观察引入相关标签后，原始标签 `L` 的召回率是否有所提升，或者是否能找回一些原本可能因图的局限性而丢失的相关结果。

---

这个新方案通过在查询入口处进行标签扩展，直接利用了 `iterate_to_fixed_point` 已经支持的多标签OR逻辑，避免了修改复杂的建图剪枝过程，逻辑上更清晰，也更有可能直接达到你想要的效果。